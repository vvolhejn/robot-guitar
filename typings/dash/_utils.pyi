"""
This type stub file was generated by pyright.
"""

import collections
from typing import Union
from dash.types import RendererHooks

logger = ...
def to_json(value): # -> str | Any | None:
    ...

def interpolate_str(template, **data):
    ...

def format_tag(tag_name, attributes, inner=..., closed=..., opened=..., sanitize=...): # -> str:
    ...

def generate_hash(): # -> str:
    ...

def patch_collections_abc(member): # -> Any:
    ...

class AttributeDict(dict):
    """Dictionary subclass enabling attribute lookup/assignment of keys/values.

    For example::
        >>> m = AttributeDict({'foo': 'bar'})
        >>> m.foo
        'bar'
        >>> m.foo = 'not bar'
        >>> m['foo']
        'not bar'
    ``AttributeDict`` objects also provide ``.first()`` which acts like
    ``.get()`` but accepts multiple keys as arguments, and returns the value of
    the first hit, e.g.::
        >>> m = AttributeDict({'foo': 'bar', 'biz': 'baz'})
        >>> m.first('wrong', 'incorrect', 'foo', 'biz')
        'bar'
    """
    def __setattr__(self, key, value): # -> None:
        ...
    
    def __getattr__(self, key):
        ...
    
    def set_read_only(self, names, msg=...): # -> None:
        """
        Designate named attributes as read-only with the corresponding msg

        Method is additive. Making additional calls to this method will update
        existing messages and add to the current set of _read_only names.
        """
        ...
    
    def finalize(self, msg=...): # -> None:
        """Prevent any new keys being set."""
        ...
    
    def __setitem__(self, key, val): # -> None:
        ...
    
    def update(self, other): # -> None:
        ...
    
    def first(self, *names): # -> dict[Any, Any] | None:
        ...
    


def create_callback_id(output, inputs, no_output=...): # -> str | LiteralString:
    ...

def split_callback_id(callback_id): # -> list[Any] | dict[str, Any]:
    ...

def stringify_id(id_): # -> str:
    ...

def inputs_to_dict(inputs_list): # -> AttributeDict:
    ...

def convert_to_AttributeDict(nested_list): # -> list[Any]:
    ...

def inputs_to_vals(inputs): # -> list[list[Any] | Any]:
    ...

def run_command_with_process(cmd): # -> None:
    ...

def compute_hash(path): # -> str:
    ...

def job(msg=...): # -> Callable[..., _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]]:
    ...

def gen_salt(chars): # -> str:
    ...

class OrderedSet(collections.abc.MutableSet):
    def __init__(self, *args) -> None:
        ...
    
    def add(self, value): # -> None:
        ...
    
    def discard(self, value): # -> None:
        ...
    
    def __contains__(self, x): # -> bool:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __iter__(self): # -> Generator[Any, Any, None]:
        ...
    


def coerce_to_list(obj): # -> list[Any] | tuple[Any, ...]:
    ...

def clean_property_name(name: str): # -> str:
    ...

def hooks_to_js_object(hooks: Union[RendererHooks, None]) -> str:
    ...

def parse_version(version): # -> tuple[int, ...]:
    ...

def get_caller_name(): # -> Any | Literal['__main__']:
    ...

