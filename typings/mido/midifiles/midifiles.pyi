"""
This type stub file was generated by pyright.
"""

"""
MIDI file reading and playback.

References:

http://home.roadrunner.com/~jgglatt/
http://home.roadrunner.com/~jgglatt/tech/miditech.htm
http://home.roadrunner.com/~jgglatt/tech/midifile.htm

http://www.sonicspot.com/guide/midifiles.html
http://www.ccarh.org/courses/253/assignment/midifile/
https://code.google.com/p/binasc/wiki/mainpage
http://stackoverflow.com/questions/2984608/midi-delta-time
http://www.recordingblogs.com/sa/tabid/82/EntryId/44/MIDI-Part-XIII-Delta-time-a
http://www.sonicspot.com/guide/midifiles.html
"""
DEFAULT_TEMPO = ...
DEFAULT_TICKS_PER_BEAT = ...
MAX_MESSAGE_LENGTH = ...
def print_byte(byte, pos=...): # -> None:
    ...

class DebugFileWrapper:
    def __init__(self, file) -> None:
        ...
    
    def read(self, size):
        ...
    
    def tell(self):
        ...
    


def read_byte(self): # -> int:
    ...

def read_bytes(infile, size): # -> list[int]:
    ...

def read_chunk_header(infile): # -> tuple[Any, ...]:
    ...

def read_file_header(infile): # -> tuple[Any, ...]:
    ...

def read_message(infile, status_byte, peek_data, delta, clip=...): # -> Message:
    ...

def read_sysex(infile, delta, clip=...): # -> Message:
    ...

def read_variable_int(infile): # -> int:
    ...

def read_meta_message(infile, delta): # -> MetaMessage | UnknownMetaMessage:
    ...

def read_track(infile, debug=..., clip=...): # -> MidiTrack:
    ...

def write_chunk(outfile, name, data): # -> None:
    """Write an IFF chunk to the file.

    `name` must be a bytestring."""
    ...

def write_track(outfile, track): # -> None:
    ...

def get_seconds_per_tick(tempo, ticks_per_beat):
    ...

class MidiFile:
    def __init__(self, filename=..., file=..., type=..., ticks_per_beat=..., charset=..., debug=..., clip=..., tracks=...) -> None:
        ...
    
    @property
    def merged_track(self): # -> MidiTrack:
        ...
    
    @merged_track.deleter
    def merged_track(self): # -> None:
        ...
    
    def add_track(self, name=...): # -> MidiTrack:
        """Add a new track to the file.

        This will create a new MidiTrack object and append it to the
        track list.
        """
        ...
    
    @property
    def length(self): # -> int:
        """Playback time in seconds.

        This will be computed by going through every message in every
        track and adding up delta times.
        """
        ...
    
    def __iter__(self): # -> Generator[Any, Any, None]:
        ...
    
    def play(self, meta_messages=..., now=...): # -> Generator[Any | MetaMessage, Any, None]:
        """Play back all tracks.

        The generator will sleep between each message by
        default. Messages are yielded with correct timing. The time
        attribute is set to the number of seconds slept since the
        previous message.

        By default you will only get normal MIDI messages. Pass
        meta_messages=True if you also want meta messages.

        You will receive copies of the original messages, so you can
        safely modify them without ruining the tracks.

        By default the system clock is used for the timing of yielded
        MIDI events. To use a different clock (e.g. to synchronize to
        an audio stream), pass now=time_fn where time_fn is a zero
        argument function that yields the current time in seconds.
        """
        ...
    
    def save(self, filename=..., file=...): # -> None:
        """Save to a file.

        If file is passed the data will be saved to that file. This is
        typically an in-memory file or and already open file like sys.stdout.

        If filename is passed the data will be saved to that file.

        Raises ValueError if both file and filename are None,
        or if a type 0 file has != one track.
        """
        ...
    
    def print_tracks(self, meta_only=...): # -> None:
        """Prints out all messages in a .midi file.

        May take argument meta_only to show only meta messages.

        Use:
        print_tracks() -> will print all messages
        print_tracks(meta_only=True) -> will print only MetaMessages
        """
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __enter__(self): # -> Self:
        ...
    
    def __exit__(self, type, value, traceback): # -> Literal[False]:
        ...
    


