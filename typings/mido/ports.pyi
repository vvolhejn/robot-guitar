"""
This type stub file was generated by pyright.
"""

"""
Useful tools for working with ports
"""
_DEFAULT_SLEEP_TIME = ...
_sleep_time = ...
def sleep(): # -> None:
    """Sleep for N seconds.

    This is used in ports when polling and waiting for messages. N can
    be set with set_sleep_time()."""
    ...

def set_sleep_time(seconds=...): # -> None:
    """Set the number of seconds sleep() will sleep."""
    ...

def get_sleep_time(): # -> float:
    """Get number of seconds sleep() will sleep."""
    ...

def reset_messages(): # -> Generator[Message, Any, None]:
    """Yield "All Notes Off" and "Reset All Controllers" for all channels"""
    ...

def panic_messages(): # -> Generator[Message, Any, None]:
    """Yield "All Sounds Off" for all channels.

    This will mute all sounding notes regardless of
    envelopes. Useful when notes are hanging and nothing else
    helps.
    """
    ...

class DummyLock:
    def __enter__(self): # -> Self:
        ...
    
    def __exit__(self, *_): # -> Literal[False]:
        ...
    


class BasePort:
    """
    Abstract base class for Input and Output ports.
    """
    is_input = ...
    is_output = ...
    _locking = ...
    def __init__(self, name=..., **kwargs) -> None:
        ...
    
    def close(self): # -> None:
        """Close the port.

        If the port is already closed, nothing will happen.  The port
        is automatically closed when the object goes out of scope or
        is garbage collected.
        """
        ...
    
    def __del__(self): # -> None:
        ...
    
    def __enter__(self): # -> Self:
        ...
    
    def __exit__(self, type, value, traceback): # -> Literal[False]:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class BaseInput(BasePort):
    """Base class for input port.

    Subclass and override _receive() to create a new input port type.
    (See portmidi.py for an example of how to do this.)
    """
    is_input = ...
    def __init__(self, name=..., **kwargs) -> None:
        """Create an input port.

        name is the port name, as returned by input_names(). If
        name is not passed, the default input is used instead.
        """
        ...
    
    def iter_pending(self): # -> Generator[Any, Any, None]:
        """Iterate through pending messages."""
        ...
    
    def receive(self, block=...): # -> None:
        """Return the next message.

        This will block until a message arrives.

        If you pass block=False it will not block and instead return
        None if there is no available message.

        If the port is closed and there are no pending messages IOError
        will be raised. If the port closes while waiting inside receive(),
        IOError will be raised. TODO: this seems a bit inconsistent. Should
        different errors be raised? What's most useful here?
        """
        ...
    
    def poll(self): # -> None:
        """Receive the next pending message or None

        This is the same as calling `receive(block=False)`."""
        ...
    
    def __iter__(self): # -> Generator[Any | None, Any, None]:
        """Iterate through messages until the port closes."""
        ...
    


class BaseOutput(BasePort):
    """
    Base class for output port.

    Subclass and override _send() to create a new port type.  (See
    portmidi.py for how to do this.)
    """
    is_output = ...
    def __init__(self, name=..., autoreset=..., **kwargs) -> None:
        """Create an output port

        name is the port name, as returned by output_names(). If
        name is not passed, the default output is used instead.
        """
        ...
    
    def send(self, msg): # -> None:
        """Send a message on the port.

        A copy of the message will be sent, so you can safely modify
        the original message without any unexpected consequences.
        """
        ...
    
    def reset(self): # -> None:
        """Send "All Notes Off" and "Reset All Controllers" on all channels"""
        ...
    
    def panic(self): # -> None:
        """Send "All Sounds Off" on all channels.

        This will mute all sounding notes regardless of
        envelopes. Useful when notes are hanging and nothing else
        helps.
        """
        ...
    


class BaseIOPort(BaseInput, BaseOutput):
    def __init__(self, name=..., **kwargs) -> None:
        """Create an IO port.

        name is the port name, as returned by ioport_names().
        """
        ...
    


class IOPort(BaseIOPort):
    """Input / output port.

    This is a convenient wrapper around an input port and an output
    port which provides the functionality of both. Every method call
    is forwarded to the appropriate port.
    """
    _locking = ...
    def __init__(self, input, output) -> None:
        ...
    


class EchoPort(BaseIOPort):
    __iter__ = ...


class MultiPort(BaseIOPort):
    def __init__(self, ports, yield_ports=...) -> None:
        ...
    


def multi_receive(ports, yield_ports=..., block=...): # -> Generator[tuple[Any, Any] | Any, Any, None]:
    """Receive messages from multiple ports.

    Generates messages from ever input port. The ports are polled in
    random order for fairness, and all messages from each port are
    yielded before moving on to the next port.

    If yield_ports=True, (port, message) is yielded instead of just
    the message.

    If block=False only pending messages will be yielded.
    """
    ...

def multi_iter_pending(ports, yield_ports=...): # -> Generator[tuple[Any, Any] | Any, Any, None]:
    """Iterate through all pending messages in ports.

    This is the same as calling multi_receive(ports, block=False).
    The function is kept around for backwards compatability.
    """
    ...

def multi_send(ports, msg): # -> None:
    """Send message on all ports."""
    ...

